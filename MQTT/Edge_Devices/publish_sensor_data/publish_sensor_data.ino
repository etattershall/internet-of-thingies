
#include <SoftwareSerial.h>
#include <ArduinoJson.h>

// Define the pins used for inputs and outputs
int digital_inputs [0] = {};
int analog_inputs [2] = {0, 1};
int outputs [2] = {7, 8};


// Choose names for the inputs and outputs
// Note: don't use A5, since we are using this pin to set the random seed
String digital_inputs_names [0] = {};
String analog_inputs_names [2] = {"LDR", "Thermistor"};
String outputs_names [2] = {"Red_LED", "Green_LED"};


const int LED = 7;
const int SENSOR = 0;

// Create an empty string to store incoming data in
String data = "";

// Store a value for last publish time
long previous_time = 0; 
long interval = 5000; 

// This variable will hold a random number generated by the random() function
long device_id;

void setup() {
  Serial.begin(9600);

  // Set the digital pins as appropriate
  for (int i=0; i<sizeof(digital_inputs); i++) {
    pinMode(digital_inputs[i], INPUT);
  }
  for (int i=0; i<sizeof(outputs); i++) {
    pinMode(outputs[i], OUTPUT);
  } 
  
  // Create a random seed by reading on the analogue pin
  randomSeed(analogRead(A5));
  // Set a four digit device id
  device_id = random(1000,10000);
}

void loop() {
  // Set the json buffer
  StaticJsonBuffer<500> jsonBuffer;

  // If there is data available to read from the serial port, append it to our data string
  if (Serial.available()) 
  {
    int inbyte = Serial.read();
    data = data + char(inbyte);
    
  }
  // If there is no new data available...
  else {
    // But we have some stored..
    if (data.length() > 0){
      // Attempt to parse it
      JsonObject& incoming_message = jsonBuffer.parseObject(data);
      // If parsing was successful...
      if (incoming_message.success()) {
        // Do what the message says!
        if (incoming_message["topic"] == "handshake"){
          // Send back a handshake
          JsonObject& outgoing_message = jsonBuffer.createObject();
          outgoing_message["topic"] = "handshake";
          outgoing_message["payload"] = device_id;
          outgoing_message.printTo(Serial);
        }

        // Check whether the message is an instruction for one of our devices
        for (int i=0; i<sizeof(outputs); i++) {
          if (incoming_message["topic"] == outputs_names[i]){
            if (incoming_message["payload"] == "HIGH") {
              digitalWrite(outputs[i], HIGH);
            }
            else if (incoming_message["payload"] == "LOW"){
              digitalWrite(outputs[i], LOW);
            }
          }
        }
        // If the message was a success, we no longer need the message data.
        // clear it out ready for the next message
        data = "";
      }
    }

    // If there is no data to read and no data is stored:
    else {
      
    // Check if we are ready to send new data
    unsigned long current_time = millis();
    if(current_time - previous_time > interval) {
      previous_time = current_time;
      
      // Send data about each sensor
      for (int i=0; i<sizeof(digital_inputs); i++) {
        int sensor_state = digitalRead(SENSOR);
        JsonObject& outgoing_message = jsonBuffer.createObject();
        outgoing_message["topic"] = digital_inputs_names[i];
        outgoing_message["payload"] = sensor_state;
        outgoing_message.printTo(Serial);
      }

      // Send data about each sensor
      for (int i=0; i<sizeof(analog_inputs); i++) {
        int sensor_state = analogRead(SENSOR);
        JsonObject& outgoing_message = jsonBuffer.createObject();
        outgoing_message["topic"] = analog_inputs_names[i];
        outgoing_message["payload"] = sensor_state;
        outgoing_message.printTo(Serial);
      }

      
    
    }
  }
  }
  delay(10);
}


